!	copyright Evan. J. Gowan, 2013, 2017
!
!	This file is part of countour_interpolation
!
!	ICESHEET is free software: you can redistribute it and/or modify
!	it under the terms of the GNU General Public License as published by
!	the Free Software Foundation, version 3 of the License
!
!	ICESHEET is distributed in the hope that it will be useful,
!	but WITHOUT ANY WARRANTY; without even the implied warranty of
!	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!	GNU General Public License for more details.
!
!	You should have received a copy of the GNU General Public License
!	along with countour_interpolation.  If not, see <http://www.gnu.org/licenses/>.

!***********************************************************************************

! This program takes an input file with points that give a direction of ice sheet advance/retreat, plus a triangular irregular network produced by GMT
! and interpolates linearly to a regular grid. The user must define a grid spacing from command line

! This program was originally written for use in Gowan (2013), to determine the minimum timing of retreat. This version
! alters it so that it is more general, taking in only the arguments from find_direction and the TIN generated by GMT, plus
! a grid spacing.

! Gowan, E.J., 2013. An assessment of the minimum timing of ice free conditions of the 
!   western Laurentide Ice Sheet. Quaternary Science Reviews, 75, pp.100-113.


program interpolate_direction

	use pip
	use direction_mod
	use read_minmax
	use direction_grid_mod

	implicit none





!	double precision :: x, y

!	double precision :: grid_spacing_final

!	double precision :: sum_x, sum_y, coarse_to_fine_x, coarse_to_fine_y, grid_ratio
!	integer :: fine_grid_x, fine_grid_y, fine_counter, half_grid, fine_x_counter, fine_y_counter

!	double precision, dimension(:,:), allocatable ::  direction_grid_final
!	logical, dimension(:,:), allocatable :: direction_mask_final

	! check all variables

	integer :: commandline_count, tin_file_size, number_tin_units, number_x_final, number_y_final, istat, tin_counter, rec_num
	integer :: min_x_index, min_y_index, max_x_index, max_y_index, number_x, number_y, index_counter, x_counter, y_counter
	integer ::  iteration
	integer, parameter :: points_in_triangle = 3
	integer, parameter :: dir_unit = 30, tin_unit = 50, gmt_unit=80
	integer(kind=4), dimension(3) :: index_values

	double precision ::  grid_spacing
	double precision :: slope1, slope2, intercept1, intercept2, distance1, distance2
	double precision :: current_x, current_y, crossover_x, crossover_y, interpolate_factor,  distance3
	double precision :: distance4, interpolate1, interpolate2, angle1, angle2, angle3, angle4
	double precision, dimension(3) :: x_triangle, y_triangle, direction_triangle


	character(len=256) :: arg_in
	character (len=256), parameter :: dir_file = "direction_file.bin"
	character (len=256), parameter :: tin_file="direction_file.tin"


	character (len=256), parameter :: gmt_file = "direction_grid.txt"


	logical :: check_inside, check_infinity, check_infinity2
	logical, dimension(:,:), allocatable :: polygon_max

	! requires two input parameters from command line, the grid spacing and the size of the tin file in bytes

	commandline_count = command_argument_count()

	if(commandline_count /= 2) THEN
		write(6,*) "correct usage of this program:"
		write(6,*) "interpolate_direction grid_spacing tin_file_size"
		write(6,*) "the tin file size must be in bytes (i.e. du -b direction_file.tin )"
		stop
	endif

	call GET_COMMAND_ARGUMENT(1,arg_in) 
	read(arg_in,*) grid_spacing

	call GET_COMMAND_ARGUMENT(2,arg_in) 
	read(arg_in,*) tin_file_size


	! file size divided by four bytes (record length), and three records per TIN
	number_tin_units = tin_file_size / (3*4) 

	! find grid parameters
	call run_read_minmax(grid_spacing)

	! boundary_direction.bin is an xyz file in km
	open(unit=dir_unit, file=dir_file, access="direct", form="unformatted", recl=8, status="old")

	! boundary_direction.tin contains the triangulated irregular network for the boundary
	open(unit=tin_unit, file=tin_file, access="direct", form="unformatted", recl=4, status="old")



	! allocate arrays

	call read_direction_grid_init(number_x_grid,number_y_grid)


	! create a mask of the polygon points


	! set the direction_mask to be false

	direction_mask = .false.

	do iteration = 1, 2

		! There are two iterations, this ensures that the grid points in the neighbourhood of the boundary polygons
		! but not within the TIN network are included. Most of the points far outside the boundary will be nonsense, 
		! but that shouldn't matter.

		write(6,*) "iteration: ", iteration

		if (iteration == 1) THEN
			check_inside = .true.
		else
			check_inside = .false.
		endif

		do tin_counter = 1, number_tin_units, 1

			! read in the index values of the corners of the triangle from the TIN

			rec_num = (tin_counter - 1) * (3) + 1

			read(unit=tin_unit, rec=rec_num) index_values(1)
			rec_num= rec_num + 1
			read(unit=tin_unit, rec=rec_num) index_values(2)
			rec_num= rec_num + 1
			read(unit=tin_unit, rec=rec_num) index_values(3)


			! read in the values of the triangles

			do index_counter = 1, 3, 1

				rec_num = index_values(index_counter) * 3 + 1
				read(unit=dir_unit, rec=rec_num) x_triangle(index_counter)
				rec_num = rec_num + 1
				read(unit=dir_unit, rec=rec_num) y_triangle(index_counter)
				rec_num = rec_num + 1
				read(unit=dir_unit, rec=rec_num) direction_triangle(index_counter)


			end do

			! the first part of the interpolation is to find the slope and intercept of one of the line segments of the triangle, 
			! these will remain constant throughout the next steps

			if (x_triangle(1) /= x_triangle(2)) THEN

				slope1 = (y_triangle(1) - y_triangle(2)) / (x_triangle(1) - x_triangle(2))
				angle1 = atan2((y_triangle(1) - y_triangle(2)),(x_triangle(1) - x_triangle(2)))
				intercept1 = y_triangle(1) - slope1 * x_triangle(1)
				check_infinity = .false.

			else

				slope1 = 1.e15
				if(y_triangle(1) > y_triangle(2)) THEN
					angle1 = pi
				else
					angle1 = -pi
				endif

				intercept1 = x_triangle(1)
				check_infinity = .true.

			endif

			distance1 = sqrt( (y_triangle(1) - y_triangle(2))**2 + (x_triangle(1) - x_triangle(2))**2)

!			if(x_triangle(1) == x_triangle(2)) THEN
!				check_infinity = .true.
!				write(6,*) "slope1 is infinite"
!				write(61,*) x_triangle(1), y_triangle(1)
!				write(61,*) x_triangle(2), y_triangle(2)
!				write(61,*) x_triangle(3), y_triangle(3)
!
!
!			else
				check_infinity = .false.
!			endif
		
			! find the range of x and y values, and convert them to a range for the direction_grid array


			min_x_index = nint((minval(x_triangle)-min_x_grid) / grid_spacing)
			min_y_index = nint((minval(y_triangle)-min_y_grid) / grid_spacing)
			max_x_index = nint((maxval(x_triangle)-min_x_grid) / grid_spacing) + 1
			max_y_index = nint((maxval(y_triangle)-min_y_grid) / grid_spacing) + 1


			if (max_x_index > number_x_grid) THEN
				max_x_index = number_x_grid
			endif
			if (max_y_index > number_y_grid) THEN
				max_y_index = number_y_grid
			endif

			if (min_x_index < 1) THEN
				min_x_index = 1
			endif
			if (min_y_index < 1) THEN
				min_y_index = 1
			endif


			! loop through these values

			do x_counter = min_x_index, max_x_index, 1
				do y_counter = min_y_index, max_y_index, 1

					current_x = dble(x_counter-1) * grid_spacing + min_x_grid
					current_y = dble(y_counter-1) * grid_spacing + min_y_grid

					

					! first check if the current point has already been added

					if( direction_mask(x_counter, y_counter)) THEN

						cycle

					else
						! check if inside triangle (first iteration), or outside the triangle (second iteration)
					
						if(point_in_polygon(x_triangle, y_triangle, current_x, current_y, points_in_triangle) &
						   .eqv.check_inside) THEN ! proceed!


							if(x_triangle(3) /= current_x) THEN
								slope2 = (y_triangle(3) - current_y) / (x_triangle(3) - current_x)
								angle2 = atan2((y_triangle(1) - y_triangle(2)),(x_triangle(1) - x_triangle(2)))
								intercept2 = y_triangle(3) - slope2 * x_triangle(3)
								check_infinity2 = .false.
							else

								check_infinity2 = .true.

							endif

							if(abs(slope2-slope1) < 1.0e-8) THEN ! prevents the lines from being parallel
								slope2 = slope2 + 1.1e-8
							endif

							if(.not.check_infinity) THEN

								! find the crossover point between the two lines

								if(.not. check_infinity2) THEN
									
									crossover_x = (intercept1 - intercept2) / (slope2 - slope1)
									crossover_y = slope1 * crossover_x + intercept1

								else
								!	write(6,*) "slope2 is infinite"
									crossover_x = current_x
									crossover_y = slope1 * current_x + intercept1

								endif
					
							else

								if(x_triangle(3) /= current_x) THEN
								!	write(6,*) "slope1 is infinite"
									crossover_x = x_triangle(1)
									crossover_y = slope2 * x_triangle(1) + intercept2
								else ! both lines are parallel
									write(6,*) "both lines are parallel, which makes no sense since"
									write(6,*) "that should mean that current_x is outside of the triangle"
									write(6,*) "1 and 2 are the same, and 3 and 4 are the same"

									write(6,*) x_triangle(1), y_triangle(1)
									write(6,*) x_triangle(2), y_triangle(2)
									write(6,*) x_triangle(3), y_triangle(3)
									write(6,*) current_x, current_y
								endif

							endif


							! next interpolate the angle along line 1 to the crossover point

							distance2 = sqrt( (y_triangle(1) - crossover_y)**2 + (x_triangle(1) - crossover_x)**2)


							if(angle2 /= angle1) then ! the crossover point is in the opposite direction of t1,t2
								interpolate_factor = 0
							elseif (distance2 > distance1) THEN ! crossover point is not on t1,t2, beyond t2
								interpolate_factor = 1
							else
								interpolate_factor = distance2 / distance1
								interpolate1 = general_direction(direction_triangle(1), direction_triangle(2), &
									interpolate_factor)
							endif


							! now interpolate from the crossover point to the grid point

							distance3 = sqrt( (y_triangle(3) - crossover_y)**2 + (x_triangle(3) - crossover_x)**2)
							angle3 = atan2((y_triangle(3) - crossover_y),(x_triangle(3) - crossover_x))
							distance4 = sqrt( (y_triangle(3) - current_y)**2 + (x_triangle(3) - current_x)**2)
							angle4 = atan2((y_triangle(3) - current_y),(x_triangle(3) - current_x))

							if (abs(angle3 - angle4) > 0.0000001) THEN ! there were precision problems with direct comparison
								interpolate_factor = 0
							elseif(distance4 > distance3) THEN
								interpolate_factor = 1
							else
								interpolate_factor = distance4 / distance3
							endif


							interpolate2 = general_direction(direction_triangle(3), interpolate1, interpolate_factor)

							if(isnan(interpolate2)) THEN
								write(6,*) slope2, slope1
								write(6,*) direction_triangle(1), direction_triangle(2), direction_triangle(3)
								write(6,*) x_triangle(1), y_triangle(1)
								write(6,*) x_triangle(2), y_triangle(2)
								write(6,*) x_triangle(3), y_triangle(3)
								write(6,*) current_x, current_y
								write(6,*) distance1, distance2, distance3, distance4
								write(6,*) interpolate1, interpolate_factor
								stop
							endif

							direction_grid(x_counter, y_counter) = interpolate2

							direction_mask(x_counter, y_counter) = .true.
	
						end if
					endif
				end do
			end do
		end do
	end do

	close(unit=dir_unit)
	close(unit=tin_unit)

! write out the results



	call write_direction_grid(number_x_grid,number_y_grid)


	! write GMT file for plotting/debugging

	open(unit=gmt_unit, file=gmt_file, access="sequential", form="formatted", status="replace")

	do x_counter = 1, number_x_grid, 1
		do y_counter = 1, number_y_grid, 1

			if(  direction_mask(x_counter, y_counter)) THEN
				current_x = dble(x_counter-1) * grid_spacing + min_x_grid
				current_y = dble(y_counter-1) * grid_spacing + min_y_grid

				write(gmt_unit,*) current_x, current_y, direction_grid(x_counter,y_counter) * 180. / pi, 0.01
			endif

		end do
	end do

	close(unit=gmt_unit)

	! clear memory

	call read_direction_grid_clear()

contains


end program interpolate_direction
